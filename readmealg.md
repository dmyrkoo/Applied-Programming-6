README — Алгоритм работы логгера (Log4j2) для проекта «Залізничний транспорт»

Цель документа

Дать подробный пошаговый алгоритм работы логирования, показать примеры кода (инициализация, вызовы логера, обработка исключений) и подробно описать сложности, с которыми мы столкнулись при интеграции Log4j2 в проект.

Краткая архитектура

- Log4j2 управляется конфигурационным файлом `src/main/resources/log4j2.xml`.
- В тестах используется `src/test/resources/log4j2-test.xml`, чтобы предотвратить отправку почты.
- В коде каждый сервис/класс, где нужно логирование, получает статический Logger:
  private static final Logger logger = LogManager.getLogger(Класс.class);

Цели логирования

1. Записывать информационные события (INFO) — бизнес-действия: создание потяга, добавление вагонов, сохранение в файл.
2. Записывать предупреждения (WARN) — некритичные проблемы, неправильный ввод.
3. Записывать ошибки (ERROR/FATAL) — критичные сбои; эти записи также должны отправляться по e-mail через SMTP appender.

Файлы конфигурации и где что лежит

- `src/main/resources/log4j2.xml` — основная конфигурация. Содержит FileAppender (пишет в logs/application.log) и SMTP Appender (отправляет ERROR/FATAL на почту).
- `src/test/resources/log4j2-test.xml` — тестовая конфигурация (только Console, уровень WARN), используется автоматически при запуске `mvn test`.

Зависимости (pom.xml)

Ключевые зависимости, которые были/должны быть в `pom.xml`:
- org.apache.logging.log4j:log4j-api
- org.apache.logging.log4j:log4j-core
- org.apache.logging.log4j:log4j-slf4j-impl (опционально)
- com.sun.mail:jakarta.mail (для SMTP Appender)

Инициализация логера в коде (пример)

Пример для сервиса `TrainService` (переведено в общий вид):

package services;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

public class TrainService {
    private static final Logger logger = LogManager.getLogger(TrainService.class);

    public void createTrain(String name) {
        // бизнес-логика создания
        logger.info("Потяг успішно створено: {}", name);
    }
}

Пример для `FileManager` (обработка IO):

public class FileManager {
    private static final Logger logger = LogManager.getLogger(FileManager.class);

    public static void save(Train train, String filename) throws IOException {
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(filename))) {
            // ... write data ...
            logger.info("Дані успішно збережено у файл: {}", filename);
        } catch (IOException e) {
            logger.error("Критична помилка при збереженні файлу: {}", filename, e);
            throw e;
        }
    }
}

Примеры вызовов логера

- Информационные сообщения (INFO):
  logger.info("Потяг успішно створено: {}", train.getName());

- Предупреждения (WARN):
  logger.warn("Некоректний ввід у полі 'пасажири': {}", rawInput);

- Ошибки с трассировкой (ERROR):
  try {
      // код, который может упасть
  } catch (Exception e) {
      logger.error("Несподівана помилка при збереженні", e);
  }

Правила отправки почты

- SMTP Appender в `log4j2.xml` настроен на bufferSize="1" и ThresholdFilter level="ERROR" — это означает, что любое сообщение уровня ERROR или выше будет отправлено (по одному письму).
- В `log4j2.xml` обязательно заменить плейсхолдеры `smtpUsername` и `smtpPassword` на реальные значения или обеспечить чтение их из переменных окружения (рекомендуется).

Безопасность и тесты

- Никогда не храните реальные пароли в репозитории. Используйте переменные окружения или CI secrets.
- Для тестов создан `log4j2-test.xml` (без SMTP) — это предотвращает «почтовый спам» при запуске тестов.

Как тестировать отправку почты локально

1. В `src/main/resources/log4j2.xml` временно укажите рабочие данные SMTP (или используйте тестовый почтовый шлюз).
2. В коде вызовите запись ERROR, например:
   logger.error("Тестовая критическая ошибка для проверки SMTP", new RuntimeException("SMTP Test"));
3. Проверьте почту получателя.
4. Сразу же откатите реальные креды из репозитория и удалите тестовую генерацию ошибки.

Тонкости и типичные проблемы (ДЕТАЛЬНО)

1) Проблема Byte Buddy / Mockito при новых версиях JDK
   Симптом: при запуске тестов Mockito кидает исключение, связанное с Byte Buddy: "Java 25 (69) is not supported by the current version of Byte Buddy...".
   Причина: версия Byte Buddy, используемая Mockito, не поддерживает новый байткод конкретной версии JDK.
   Решения, которые мы применили:
   - Добавили аргумент JVM для Surefire: <argLine>-Dnet.bytebuddy.experimental=true</argLine>. Это включает экспериментальную поддержку инструментирования.
   - Если это не помогает, рекомендуется обновить Mockito/Byte Buddy до совместимых версий или запускать тесты на ранее поддерживаемой версии JDK.

2) Проблема с отсутствующей зависимостью `mockito-inline`
   Симптом: maven не может разрешить `org.mockito:mockito-inline:5.11.0` из центрального репозитория.
   Решение: временно убрали эту зависимость; для большинства случаев `mockito-core` + `mockito-junit-jupiter` достаточно.

3) Нежелательная отправка писем при тестах
   Решение: создали `log4j2-test.xml` в `src/test/resources`, который переопределяет аппендеры и убирает SMTP. Log4j2 автоматически использует его при тестах.

4) Корректная конфигурация SMTP для Gmail
   - Gmail требует App Password при включенной двухфакторной аутентификации. Необходимо создать пароль приложения и использовать его.
   - Порт: 587 (STARTTLS) — задается в конфиге.
   - Рекомендуется использовать внешнюю обертку (например, SendGrid) для надёжности.

Рекомендуемые дополнительные улучшения

- Использовать RollingFileAppender вместо простого FileAppender, чтобы лог-файлы автоматически ротировались.
- Использовать шаблон логирования с MDC (Mapped Diagnostic Context), чтобы добавлять контекст (ID сессии, пользователь) к каждому сообщению.
- Хранить чувствительные данные (smtpPassword) во внешнем секретном хранилище и загружать в окружение CI.

Вывод и подробный заключительный раздел (сложности при разработке)

В ходе добавления логирования мы столкнулись с несколькими классическими проблемами интеграции:

1) Сложности с инструментированием кода во время тестов (Mockito + Byte Buddy). Решение потребовало изменений в конфигурации запуска тестов (argLine для Surefire) и рассмотрения альтернатив (обновление библиотек или запуск на другом JDK). Это типичная проблема при переходе на новые версии JDK — байткод меняется и библиотека, которая модифицирует классы во время выполнения, должна обновляться.

2) Проблемы с зависимостями — не все артефакты доступны в центральном репозитории в указанных версиях. Здесь пришлось убрать опциональную зависимость `mockito-inline`. Для стабильной CI-среды рекомендую зафиксировать версии библиотек и проверять доступность артефактов заранее.

3) Безопасность — отправка реальных писем с ошибками в фазе разработки может привести к «спаму» и утечке секретов. Решение: предоставить тестовую конфигурацию логера, отказаться от хранения паролей в коде, использовать environment variables и CI secrets.

4) Тонкости настройки SMTP — разные провайдеры требуют различных настроек: TLS vs SSL, порты, политики приложения. Gmail, например, требует App Password при двухфакторной аутентификации.

Итог: логирование добавлено безопасно и гибко. В проект добавлены основные конфиги и README-описания. Основная рекомендация — не хранить секреты в репозитории и по возможности обновить/зафиксировать версии библиотек на CI/CD сервере.

Если нужно, могу:
- Автоматически добавить RollingFileAppender и пример MDC-контекста.
- Помочь вынести SMTP креды в переменные окружения и показать, как читать их в `log4j2.xml`.
- Обновить `pom.xml` до конкретных версий Mockito/Byte Buddy, протестировав совместимость с вашей версией JDK.

